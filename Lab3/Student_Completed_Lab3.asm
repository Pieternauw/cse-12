###########################################################################
# Created by:	Nauwelaerts, Pieter
#		pnauwela
#		27 February 2023
#
# Assignment: 	Lab 3: Looping in RISC-V Assembly
#		CSE 12, Computer Systems and Assembly Language
#		UC Santa Cruz, Winter 2023
#
# Description: 	Generates .txt file of an equilateral triangle generated by user inputted int
#
# Notes: 	Intended to run with RISCV Assembler and Runtime Simulator (RARS)
###########################################################################
#
# Psuedocode:
# Prompt loop:
#	print prompt
#	assign input to register s3
#	check if s3 > 0 branch to exit if true
#	if false, print error and newline - branch to prompt loop again
# Triangle creation
#
# assign 1 to register s4 for line counter
# Outer loop:
#	check s4 > s3 - if true branch to exit loop
#	if false write 0x2a (star character) to buffer
#	assign 2 to register s5 for inner loop character counter and branch to inner loop
# Inner loop:
#	check s5 > s4 - if true branch to outer loop part 2
#	if false, check s5 == s4 - if true branch to star placement
#	if false, check s4 == s3 - if true branch to star placement
# 	if false, write 0x20 (space character) to buffer
# 	increment s5 by 1 and branch to inner loop start again
# Star placement:
#	write 0x2a (star character) to buffer
#	incrememnt s5 by 1 and branch back to inner loop start
# Outer loop part 2:
#	write to buffer 0x0a (newline character)
#	increment s4 by 1
#	return start of outer loop
# Exit loop:
#	empty

.macro exit #macro to exit program
	li a7, 10
	ecall
	.end_macro	

.macro print_str(%string1) #macro to print any string
	li a7,4 
	la a0, %string1
	ecall
	.end_macro
	
	
.macro read_n(%x)#macro to input integer n into register x
	li a7, 5
	ecall 		
	#a0 now contains user input
	addi %x, a0, 0
	.end_macro
	

.macro 	file_open_for_write_append(%str)
	la a0, %str
	li a1, 1
	li a7, 1024
	ecall
.end_macro
	
.macro  initialise_buffer_counter
	#buffer begins at location 0x10040000
	#location 0x10040000 to keep track of which address we store each character byte to 
	#actual buffer to store the characters begins at 0x10040008
	
	#initialize mem[0x10040000] to 0x10040008
	addi sp, sp, -16
	sd t0, 0(sp)
	sd t1, 8(sp)
	
	li t0, 0x10040000
	li t1, 0x10040008
	sd t1, 0(t0)
	
	ld t0, 0(sp)
	ld t1, 8(sp)
	addi sp, sp, 16
	.end_macro
	

.macro write_to_buffer(%char)
	
	
	addi sp, sp, -16
	sd t0, 0(sp)
	sd t4, 8(sp)
	
	
	li t0, 0x10040000
	ld t4, 0(t0)#t4 is starting address
	#t4 now points to location where we store the current %char byte
	
	#store character to file buffer
	li t0, %char
	sb t0, 0(t4)
	
	#update address location for next character to be stored in file buffer
	li t0, 0x10040000
	addi t4, t4, 1
	sd t4, 0(t0)
	
	ld t0, 0(sp)
	ld t4, 8(sp)
	addi sp, sp, 16
	.end_macro

.macro fileRead(%file_descriptor_register, %file_buffer_address)
#macro reads upto first 10,000 characters from file
	addi a0, %file_descriptor_register, 0
	li a1, %file_buffer_address
	li a2, 10000
	li a7, 63
	ecall
.end_macro 

.macro fileWrite(%file_descriptor_register, %file_buffer_address,%file_buffer_address_pointer)
#macro writes contents of file buffer to file
	addi a0, %file_descriptor_register, 0
	li a1, %file_buffer_address
	li a7, 64
	
	#a2 needs to contains number of bytes sent to file
	li a2, %file_buffer_address_pointer
	ld a2, 0(a2)
	sub a2, a2, a1
	
	ecall
.end_macro 

.macro print_file_contents(%ptr_register)
	li a7, 4
	addi a0, %ptr_register, 0
	ecall
	#entire file content is essentially stored as a string
.end_macro
	


.macro close_file(%file_descriptor_register)
	li a7, 57
	addi a0, %file_descriptor_register, 0
	ecall
.end_macro

.data	
	prompt: .asciz  "Enter the height of the pattern (must be greater than 0):"
	invalidMsg: .asciz  "Invalid Entry!"
	newline: .asciz  "\n" #this prints a newline
	star: .asciz "*"
	blankspace: .asciz " "
	outputMsg: .asciz  " display pattern saved to lab3_output.txt "
	filename: .asciz "lab3_output.txt"

.text

	file_open_for_write_append(filename)
	#a0 now contaimns the file descriptor (i.e. ID no.)
	#save to t6 register
	addi t6, a0, 0
	
	initialise_buffer_counter
	
	#for utilsing macro write_to_buffer, here are tips:
	#0x2a is the ASCI code input for star(*)
	#0x20  is the ASCI code input for  blankspace
	#0x0a  is the ASCI code input for  newline (/n)

	
	#START WRITING YOUR CODE FROM THIS LINE ONWARDS
	#DO NOT  use the registers a0, a1, a7, t6, sp anywhere in your code.
	
	#................ your code here..........................................................#
	#0 value for > 0
	li s2, 0
	#counter for base star loop
	li s4 1
	
prompt_loop:
	#take user input
	print_str(prompt)
	read_n(s3)
	
	#check if greater than 0
	bgt s3, s2, prompt_exit
prompt_update:
	#print invalid string message if not greater
	print_str(invalidMsg)
	print_str(newline)
	#back to prompt
	b prompt_loop 
prompt_exit:

outer_loop:
	bgt s4, s3, outer_exit	#ln_no >= ln_cnt - don't go through loop
	write_to_buffer(0x2a)	#if it isn't, place star
	li s5 2			# inner loop counter
	b inner_loop		#go to inner loop
inner_loop:
	bgt s5, s4, outer_end	#ch_inx (inner counter) >= ln_no - go to new line char and add to ln_np
	beq s4, s5, place_star	#ch_inx == ln_no - place star
	beq s3, s4, place_star	#ln_no == ln_cnt - place star
	write_to_buffer(0x20)	#else statement that places space
	addi s5, s5, 1		#add 1 to ln_chx
	b inner_loop		#repeat this loop
place_star:
	write_to_buffer(0x2a)	#place star
	addi s5, s5, 1		#add 1 to ln_chx
	b inner_loop		#repeat loop
outer_end:
	write_to_buffer(0x0a)	#write newline
	addi s4, s4, 1		#add 1 to ln_no
	b outer_loop		#back to start of outer loop
outer_exit:


	
	
	#END YOUR CODE ABOVE THIS COMMENT
	#Don't change anything below this comment!
	
	#write null character to end of file
	write_to_buffer(0x00)
	
	#write file buffer to file
	fileWrite(t6, 0x10040008,0x10040000)
	addi t5, a0, 0
	
	print_str(newline)
	print_str(outputMsg)
	
	exit
	
	
	
